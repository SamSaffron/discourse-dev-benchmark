import{assert as t,isPresentArray as e,assertNever as s,getFirst as r,getLast as n,unwrap as a,deprecate as i,asPresentArray as o,assign as l,expect as c,assertPresentArray as h,dict as u}from"@glimmer/util";import{parseWithoutProcessing as p,parse as d}from"@handlebars/parser";import{EventedTokenizer as m,EntityParser as f,HTML5NamedCharRefs as b}from"simple-html-tokenizer";import{SexpOpcodes as g}from"@glimmer/wire-format";var k=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(k||{});const y=/["&\xA0]/u,w=new RegExp(y.source,"gu"),v=/[&<>\xA0]/u,S=new RegExp(v.source,"gu");function x(t){switch(t.charCodeAt(0)){case k.NBSP:return"&nbsp;";case k.QUOT:return"&quot;";case k.AMP:return"&amp;";default:return t}}function P(t){switch(t.charCodeAt(0)){case k.NBSP:return"&nbsp;";case k.AMP:return"&amp;";case k.LT:return"&lt;";case k.GT:return"&gt;";default:return t}}function C(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const N=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);function E(){return[...N]}const T=/^\S/u;function A(t){return N.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class B{buffer="";options;constructor(t){this.options=t}handledByOverride(t,e=!1){if(void 0!==this.options.override){let s=this.options.override(t,this.options);if("string"==typeof s)return e&&T.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(t){switch(t.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(t);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(t);case"ConcatStatement":return this.ConcatStatement(t);case"Hash":return this.Hash(t);case"HashPair":return this.HashPair(t);case"ElementModifierStatement":return this.ElementModifierStatement(t)}}Expression(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(t);case"PathExpression":return this.PathExpression(t);case"SubExpression":return this.SubExpression(t)}}Literal(t){switch(t.type){case"StringLiteral":return this.StringLiteral(t);case"BooleanLiteral":return this.BooleanLiteral(t);case"NumberLiteral":return this.NumberLiteral(t);case"UndefinedLiteral":return this.UndefinedLiteral(t);case"NullLiteral":return this.NullLiteral(t)}}TopLevelStatement(t){switch(t.type){case"MustacheStatement":return this.MustacheStatement(t);case"BlockStatement":return this.BlockStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":return this.CommentStatement(t);case"TextNode":return this.TextNode(t);case"ElementNode":return this.ElementNode(t);case"Block":return this.Block(t);case"Template":return this.Template(t);case"AttrNode":return this.AttrNode(t)}}Template(t){this.TopLevelStatements(t.body)}Block(t){if(t.chained){t.body[0].chained=!0}this.handledByOverride(t)||this.TopLevelStatements(t.body)}TopLevelStatements(t){t.forEach((t=>this.TopLevelStatement(t)))}ElementNode(t){this.handledByOverride(t)||(this.OpenElementNode(t),this.TopLevelStatements(t.children),this.CloseElementNode(t))}OpenElementNode(t){this.buffer+=`<${t.tag}`;const e=[...t.attributes,...t.modifiers,...t.comments].sort(C);for(const t of e)switch(this.buffer+=" ",t.type){case"AttrNode":this.AttrNode(t);break;case"ElementModifierStatement":this.ElementModifierStatement(t);break;case"MustacheCommentStatement":this.MustacheCommentStatement(t)}t.blockParams.length&&this.BlockParams(t.blockParams),t.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(t){t.selfClosing||A(t.tag)||(this.buffer+=`</${t.tag}>`)}AttrNode(t){if(this.handledByOverride(t))return;let{name:e,value:s}=t;this.buffer+=e,("TextNode"!==s.type||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(t){"TextNode"===t.type?(this.buffer+='"',this.TextNode(t,!0),this.buffer+='"'):this.Node(t)}TextNode(t,e){var s;this.handledByOverride(t)||("raw"===this.options.entityEncoding?this.buffer+=t.chars:this.buffer+=e?(s=t.chars,y.test(s)?s.replace(w,x):s):function(t){return v.test(t)?t.replace(S,P):t}(t.chars))}MustacheStatement(t){this.handledByOverride(t)||(this.buffer+=t.trusting?"{{{":"{{",t.strip.open&&(this.buffer+="~"),this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.strip.close&&(this.buffer+="~"),this.buffer+=t.trusting?"}}}":"}}")}BlockStatement(t){this.handledByOverride(t)||(t.chained?(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=t.openStrip.open?"{{~#":"{{#",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.program.blockParams.length&&this.BlockParams(t.program.blockParams),t.chained?this.buffer+=t.inverseStrip.close?"~}}":"}}":this.buffer+=t.openStrip.close?"~}}":"}}",this.Block(t.program),t.inverse&&(t.inverse.chained||(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=t.inverseStrip.close?"~}}":"}}"),this.Block(t.inverse)),t.chained||(this.buffer+=t.closeStrip.open?"{{~/":"{{/",this.Expression(t.path),this.buffer+=t.closeStrip.close?"~}}":"}}"))}BlockParams(t){this.buffer+=` as |${t.join(" ")}|`}ConcatStatement(t){this.handledByOverride(t)||(this.buffer+='"',t.parts.forEach((t=>{"TextNode"===t.type?this.TextNode(t,!0):this.Node(t)})),this.buffer+='"')}MustacheCommentStatement(t){this.handledByOverride(t)||(this.buffer+=`{{!--${t.value}--}}`)}ElementModifierStatement(t){this.handledByOverride(t)||(this.buffer+="{{",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+="}}")}CommentStatement(t){this.handledByOverride(t)||(this.buffer+=`\x3c!--${t.value}--\x3e`)}PathExpression(t){this.handledByOverride(t)||(this.buffer+=t.original)}SubExpression(t){this.handledByOverride(t)||(this.buffer+="(",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+=")")}Params(t){t.length&&t.forEach((t=>{this.buffer+=" ",this.Expression(t)}))}Hash(t){this.handledByOverride(t,!0)||t.pairs.forEach((t=>{this.buffer+=" ",this.HashPair(t)}))}HashPair(t){this.handledByOverride(t)||(this.buffer+=t.key,this.buffer+="=",this.Node(t.value))}StringLiteral(t){this.handledByOverride(t)||(this.buffer+=JSON.stringify(t.value))}BooleanLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}NumberLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}UndefinedLiteral(t){this.handledByOverride(t)||(this.buffer+="undefined")}NullLiteral(t){this.handledByOverride(t)||(this.buffer+="null")}print(t){let{options:e}=this;if(e.override){let s=e.override(t,e);if(void 0!==s)return s}return this.buffer="",this.Node(t),this.buffer}}function L(t,e={entityEncoding:"transformed"}){if(!t)return"";return new B(e).print(t)}function O(t){return t in H}const H={component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],"link-to":["Append","Block"],log:["Call","Append"],modifier:["Call"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],"query-params":["Call"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],with:["Block"],yield:["Append"]},F=Object.freeze({line:1,column:0}),$=Object.freeze({source:"(synthetic)",start:F,end:F}),z=Object.freeze({source:"(nonexistent)",start:F,end:F}),M=Object.freeze({source:"(broken)",start:F,end:F});let I=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const _="MATCH_ANY",U="IS_INVISIBLE";class D{_whens;constructor(t){this._whens=t}first(t){for(const s of this._whens){const r=s.match(t);if(e(r))return r[0]}return null}}class V{_map=new Map;get(t,e){let s=this._map.get(t);return s||(s=e(),this._map.set(t,s),s)}add(t,e){this._map.set(t,e)}match(t){const e=function(t){switch(t){case I.Broken:case I.InternalsSynthetic:case I.NonExistent:return U;default:return t}}(t),s=[],r=this._map.get(e),n=this._map.get(_);return r&&s.push(r),n&&s.push(n),s}}function j(t){return t(new G).check()}class G{_whens=new V;check(){return(t,e)=>this.matchFor(t.kind,e.kind)(t,e)}matchFor(s,r){const n=this._whens.match(s);t(e(n),`no match defined for (${s}, ${r}) and no AnyMatch defined either`);const a=new D(n).first(r);return t(null!==a,`no match defined for (${s}, ${r}) and no AnyMatch defined either`),a}when(t,e,s){return this._whens.get(t,(()=>new V)).add(e,s),this}}const J=!("undefined"!=typeof window&&window.location&&/[&?]disable_local_debug/u.test(window.location.search));class R{static synthetic(t){let e=Y.synthetic(t);return new R({loc:e,chars:t})}static load(t,e){return new R({loc:Y.load(t,e[1]),chars:e[0]})}chars;loc;constructor(t){this.loc=t.loc,this.chars=t.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class Y{static get NON_EXISTENT(){return new q(I.NonExistent,z).wrap()}static load(t,e){return"number"==typeof e?Y.forCharPositions(t,e,e):"string"==typeof e?Y.synthetic(e):Array.isArray(e)?Y.forCharPositions(t,e[0],e[1]):e===I.NonExistent?Y.NON_EXISTENT:e===I.Broken?Y.broken(M):void s(e)}static forHbsLoc(t,e){const s=new et(t,e.start),r=new et(t,e.end);return new Q(t,{start:s,end:r},e).wrap()}static forCharPositions(t,e,s){const r=new tt(t,e),n=new tt(t,s);return new K(t,{start:r,end:n}).wrap()}static synthetic(t){return new q(I.InternalsSynthetic,z,t).wrap()}static broken(t=M){return new q(I.Broken,t).wrap()}isInvisible;constructor(t){this.data=t,this.isInvisible=t.kind!==I.CharPosition&&t.kind!==I.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const t=this.data.toHbsSpan();return null===t?M:t.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(t){return W(t.data,this.data.getEnd())}withEnd(t){return W(this.data.getStart(),t.data)}asString(){return this.data.asString()}toSlice(t){const e=this.data.asString();return void 0!==t&&e!==t&&console.warn(`unexpectedly found ${JSON.stringify(e)} when slicing source, but expected ${JSON.stringify(t)}`),new R({loc:this,chars:t||e})}get start(){return this.loc.start}set start(t){this.data.locDidUpdate({start:t})}get end(){return this.loc.end}set end(t){this.data.locDidUpdate({end:t})}get source(){return this.module}collapse(t){switch(t){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(t){return W(this.data.getStart(),t.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:t=0,skipEnd:e=0}){return W(this.getStart().move(t).data,this.getEnd().move(-e).data)}sliceStartChars({skipStart:t=0,chars:e}){return W(this.getStart().move(t).data,this.getStart().move(t+e).data)}sliceEndChars({skipEnd:t=0,chars:e}){return W(this.getEnd().move(t-e).data,this.getStart().move(-t).data)}}class K{kind=I.CharPosition;_locPosSpan=null;constructor(t,e){this.source=t,this.charPositions=e}wrap(){return new Y(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){J&&console.warn("updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase")}toHbsSpan(){let t=this._locPosSpan;if(null===t){const e=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();t=this._locPosSpan=null===e||null===s?X:new Q(this.source,{start:e,end:s})}return t===X?null:t}serialize(){const{start:{charPos:t},end:{charPos:e}}=this.charPositions;return t===e?t:[t,e]}toCharPosSpan(){return this}}class Q{kind=I.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(t,e,s=null){this.source=t,this.hbsPositions=e,this._providedHbsLoc=s}serialize(){const t=this.toCharPosSpan();return null===t?I.Broken:t.wrap().serialize()}wrap(){return new Y(this)}updateProvided(t,e){this._providedHbsLoc&&(this._providedHbsLoc[e]=t),this._charPosSpan=null,this._providedHbsLoc={start:t,end:t}}locDidUpdate({start:t,end:e}){void 0!==t&&(this.updateProvided(t,"start"),this.hbsPositions.start=new et(this.source,t,null)),void 0!==e&&(this.updateProvided(e,"end"),this.hbsPositions.end=new et(this.source,e,null))}asString(){const t=this.toCharPosSpan();return null===t?"":t.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let t=this._charPosSpan;if(null===t){const e=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!e||!s)return t=this._charPosSpan=X,null;t=this._charPosSpan=new K(this.source,{start:e,end:s})}return t===X?null:t}}class q{constructor(t,e,s=null){this.kind=t,this.loc=e,this.string=s}serialize(){switch(this.kind){case I.Broken:case I.NonExistent:return this.kind;case I.InternalsSynthetic:return this.string||""}}wrap(){return new Y(this)}asString(){return this.string||""}locDidUpdate({start:t,end:e}){void 0!==t&&(this.loc.start=t),void 0!==e&&(this.loc.end=e)}getModule(){return"an unknown module"}getStart(){return new st(this.kind,this.loc.start)}getEnd(){return new st(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return M}}const W=j((t=>t.when(I.HbsPosition,I.HbsPosition,((t,e)=>new Q(t.source,{start:t,end:e}).wrap())).when(I.CharPosition,I.CharPosition,((t,e)=>new K(t.source,{start:t,end:e}).wrap())).when(I.CharPosition,I.HbsPosition,((t,e)=>{const s=e.toCharPos();return null===s?new q(I.Broken,M).wrap():W(t,s)})).when(I.HbsPosition,I.CharPosition,((t,e)=>{const s=t.toCharPos();return null===s?new q(I.Broken,M).wrap():W(s,e)})).when(U,_,(t=>new q(t.kind,M).wrap())).when(_,U,((t,e)=>new q(e.kind,M).wrap())))),X="BROKEN";class Z{static forHbsPos(t,e){return new et(t,e,null).wrap()}static broken(t=F){return new st(I.Broken,t).wrap()}constructor(t){this.data=t}get offset(){const t=this.data.toCharPos();return null===t?null:t.offset}eql(t){return rt(this.data,t.data)}until(t){return W(this.data,t.data)}move(t){const e=this.data.toCharPos();if(null===e)return Z.broken();{const s=e.offset+t;return e.source.check(s)?new tt(e.source,s).wrap():Z.broken()}}collapsed(){return W(this.data,this.data)}toJSON(){return this.data.toJSON()}}class tt{kind=I.CharPosition;_locPos=null;constructor(t,e){this.source=t,this.charPos=e}toCharPos(){return this}toJSON(){const t=this.toHbsPos();return null===t?F:t.toJSON()}wrap(){return new Z(this)}get offset(){return this.charPos}toHbsPos(){let t=this._locPos;if(null===t){const e=this.source.hbsPosFor(this.charPos);this._locPos=t=null===e?X:new et(this.source,e,this.charPos)}return t===X?null:t}}class et{kind=I.HbsPosition;_charPos;constructor(t,e,s=null){this.source=t,this.hbsPos=e,this._charPos=null===s?null:new tt(t,s)}toCharPos(){let t=this._charPos;if(null===t){const e=this.source.charPosFor(this.hbsPos);this._charPos=t=null===e?X:new tt(this.source,e)}return t===X?null:t}toJSON(){return this.hbsPos}wrap(){return new Z(this)}toHbsPos(){return this}}class st{constructor(t,e){this.kind=t,this.pos=e}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new Z(this)}get offset(){return null}}const rt=j((t=>t.when(I.HbsPosition,I.HbsPosition,(({hbsPos:t},{hbsPos:e})=>t.column===e.column&&t.line===e.line)).when(I.CharPosition,I.CharPosition,(({charPos:t},{charPos:e})=>t===e)).when(I.CharPosition,I.HbsPosition,(({offset:t},e)=>t===e.toCharPos()?.offset)).when(I.HbsPosition,I.CharPosition,((t,{offset:e})=>t.toCharPos()?.offset===e)).when(_,_,(()=>!1))));class nt{static from(t,e={}){return new nt(t,e.meta?.moduleName)}constructor(t,e="an unknown module"){this.source=t,this.module=e}check(t){return t>=0&&t<=this.source.length}slice(t,e){return this.source.slice(t,e)}offsetFor(t,e){return Z.forHbsPos(this,{line:t,column:e})}spanFor({start:t,end:e}){return Y.forHbsLoc(this,{start:{line:t.line,column:t.column},end:{line:e.line,column:e.column}})}hbsPosFor(t){let e=0,s=0;if(t>this.source.length)return null;for(;;){let r=this.source.indexOf("\n",s);if(t<=r||-1===r)return{line:e+1,column:t-s};e+=1,s=r+1}}charPosFor(e){let{line:s,column:r}=e,n=this.source.length,a=0,i=0;for(;i<n;){let e=this.source.indexOf("\n",i);if(-1===e&&(e=this.source.length),a===s-1){if(i+r>e)return e;{let e=this.hbsPosFor(i+r);t(null!==e,"the returned offset failed to round-trip"),t(e.line===s,"the round-tripped line didn't match the original line"),t(e.column===r,"the round-tripped column didn't match the original column")}return i+r}if(-1===e)return 0;a+=1,i=e+1}return n}}class at{static range(t,e=Y.NON_EXISTENT){return new at(t.map(it)).getRangeOffset(e)}_span;constructor(t=[]){this._span=t}add(t){this._span.push(t)}getRangeOffset(t){if(e(this._span)){let t=r(this._span),e=n(this._span);return t.extend(e)}return t}}function it(t){if(Array.isArray(t)){let e=r(t),s=n(t);return it(e).extend(it(s))}return t instanceof Y?t:t.loc}function ot(t){return!Array.isArray(t)||0!==t.length}function lt(t,e){return ot(t)?it(t):e}var ct=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:z,SYNTHETIC_LOCATION:$,Source:nt,SourceOffset:Z,SourceSlice:R,SourceSpan:Y,SpanList:at,UNKNOWN_POSITION:F,hasSpan:ot,loc:it,maybeLoc:lt});function ht(t,e){let{module:s,loc:r}=e,{line:n,column:a}=r.start,i=e.asString(),o=i?`\n\n|\n|  ${i.split("\n").join("\n|  ")}\n|\n\n`:"",l=new Error(`${t}: ${o}(error occurred in '${s}' @ line ${n} : column ${a})`);return l.name="SyntaxError",l.location=e,l.code=i,l}const ut={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},pt=function(){function t(t,e,s,r){let n=Error.call(this,t);this.key=r,this.message=t,this.node=e,this.parent=s,n.stack&&(this.stack=n.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function dt(t,e,s){return new pt("Cannot remove a node unless it is part of an array",t,e,s)}function mt(t,e,s){return new pt("Cannot replace a node with multiple nodes unless it is part of an array",t,e,s)}function ft(t,e){return new pt("Replacing and removing in key handlers is not yet supported.",t,null,e)}class bt{node;parent;parentKey;constructor(t,e=null,s=null){this.node=t,this.parent=e,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new gt(this)}}}class gt{path;constructor(t){this.path=t}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function kt(t){return"function"==typeof t?t:t.enter}function yt(t){return"function"==typeof t?void 0:t.exit}function wt(t,e){let s,r,n,{node:a,parent:o,parentKey:l}=e,c=function(t,e){if(t.Program&&("Template"===e&&!t.Template||"Block"===e&&!t.Block))return i(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${e}') `),t.Program;let s=t[e];return void 0!==s?s:t.All}(t,a.type);if(void 0!==c&&(s=kt(c),r=yt(c)),void 0!==s&&(n=s(a,e)),null!=n){if(JSON.stringify(a)!==JSON.stringify(n)){if(Array.isArray(n))return xt(t,n,o,l),n;return wt(t,new bt(n,o,l))||n}n=void 0}if(void 0===n){let s=ut[a.type];for(let r=0;r<s.length;r++){St(t,c,e,s[r])}void 0!==r&&(n=r(a,e))}return n}function vt(t,e,s){t[e]=s}function St(t,e,s,r){let n,a,{node:i}=s,o=function(t,e){return t[e]}(i,r);if(o){if(void 0!==e){let t=function(t,e){let s="function"!=typeof t?t.keys:void 0;if(void 0===s)return;let r=s[e];return void 0!==r?r:s.All}(e,r);void 0!==t&&(n=kt(t),a=yt(t))}if(void 0!==n&&void 0!==n(i,r))throw ft(i,r);if(Array.isArray(o))xt(t,o,s,r);else{let e=wt(t,new bt(o,s,r));void 0!==e&&function(t,e,s,r){if(null===r)throw dt(s,t,e);if(Array.isArray(r)){if(1!==r.length)throw 0===r.length?dt(s,t,e):mt(s,t,e);vt(t,e,r[0])}else vt(t,e,r)}(i,r,o,e)}if(void 0!==a&&void 0!==a(i,r))throw ft(i,r)}}function xt(t,e,s,r){for(let n=0;n<e.length;n++){let i=a(e[n]),o=wt(t,new bt(i,s,r));void 0!==o&&(n+=Pt(e,n,o)-1)}}function Pt(t,e,s){return null===s?(t.splice(e,1),0):Array.isArray(s)?(t.splice(e,1,...s),s.length):(t.splice(e,1,s),1)}function Ct(t,e){wt(e,new bt(t))}class Nt{stack=[];constructor(t){this.order=t}visit(t,e){t&&(this.stack.push(t),"post"===this.order?(this.children(t,e),e(t,this)):(e(t,this),this.children(t,e)),this.stack.pop())}children(t,e){switch(t.type){case"Block":case"Template":return void Et(this,t.body,e);case"ElementNode":return void Et(this,t.children,e);case"BlockStatement":return this.visit(t.program,e),void this.visit(t.inverse||null,e);default:return}}}function Et(t,e,s){for(const r of e)t.visit(r,s)}function Tt(t,e){(function(t){switch(t.type){case"Block":case"Template":return t.body;case"ElementNode":return t.children}})(t).push(e)}function At(t){return"StringLiteral"===t.type||"BooleanLiteral"===t.type||"NumberLiteral"===t.type||"NullLiteral"===t.type||"UndefinedLiteral"===t.type}let Bt;function Lt(){return Bt||(Bt=new nt("","(synthetic)")),Bt}function Ot(t,e){return jt.var({name:t,loc:_t(e||null)})}function Ht(e,s){let r=_t(s||null);if("string"!=typeof e){if("type"in e)return e;{t(-1===e.head.indexOf("."),"builder.path({ head, tail }) should not be called with a head with dots in it");let{head:n,tail:a}=e;return jt.path({head:jt.head({original:n,loc:r.sliceStartChars({chars:n.length})}),tail:a,loc:_t(s||null)})}}let{head:n,tail:a}=function(t,e){let[s,...r]=o(t.split(".")),n=jt.head({original:s,loc:_t(e||null)});return jt.path({head:n,tail:r,loc:_t(e||null)})}(e,r);return jt.path({head:n,tail:a,loc:r})}function Ft(t,e,s){return jt.literal({type:t,value:e,loc:_t(s||null)})}function $t(t=[],e){return jt.hash({pairs:t,loc:_t(e||null)})}function zt(t){return t.map((t=>"string"==typeof t?jt.var({name:t,loc:Y.synthetic(t)}):t))}function Mt(t=[],e=[],s=!1,r){return jt.blockItself({body:t,params:zt(e),chained:s,loc:_t(r||null)})}function It(t=[],e=[],s){return jt.template({body:t,blockParams:e,loc:_t(s||null)})}function _t(...t){if(1===t.length){let e=t[0];return e&&"object"==typeof e?Y.forHbsLoc(Lt(),e):Y.forHbsLoc(Lt(),$)}{let[e,s,r,n,a]=t,i=a?new nt("",a):Lt();return Y.forHbsLoc(i,{start:{line:e,column:s},end:{line:r||e,column:n||s}})}}var Ut={mustache:function(t,e=[],s=$t([]),r=!1,n,a){return jt.mustache({path:Ht(t),params:e,hash:s,trusting:r,strip:a,loc:_t(n||null)})},block:function(e,s,r,n,a=null,o,l,c,h){let u,p=null;return"Template"===n.type?(i("b.program is deprecated. Use b.blockItself instead."),u=jt.blockItself({params:zt(n.blockParams),body:n.body,loc:n.loc})):u=n,"Template"===a?.type?(i("b.program is deprecated. Use b.blockItself instead."),t(0===a.blockParams.length,"{{else}} block cannot have block params"),p=jt.blockItself({params:[],body:a.body,loc:a.loc})):p=a,jt.block({path:Ht(e),params:s||[],hash:r||$t([]),defaultBlock:u,elseBlock:p,loc:_t(o||null),openStrip:l,inverseStrip:c,closeStrip:h})},comment:function(t,e){return jt.comment({value:t,loc:_t(e||null)})},mustacheComment:function(t,e){return jt.mustacheComment({value:t,loc:_t(e||null)})},element:function(e,s={}){let r,n,{attrs:a,blockParams:i,modifiers:o,comments:l,children:c,openTag:h,closeTag:u,loc:p}=s;"string"==typeof e?e.endsWith("/")?(r=Ht(e.slice(0,-1)),n=!0):r=Ht(e):"type"in e?(t("PathExpression"===e.type,`Invalid tag type ${e.type}`),r=e):"path"in e?(t("PathExpression"===e.path.type,`Invalid tag type ${e.path.type}`),r=e.path,n=e.selfClosing):(r=Ht(e.name),n=e.selfClosing),n&&t(null==u,"Cannot build a self-closing tag with a closeTag source location");let d=i?.map((t=>"string"==typeof t?Ot(t):t)),m=null;return u?m=_t(u||null):void 0===u&&(m=n||A(r.original)?null:_t(null)),jt.element({path:r,selfClosing:n||!1,attributes:a||[],params:d||[],modifiers:o||[],comments:l||[],children:c||[],openTag:_t(h||null),closeTag:m,loc:_t(p||null)})},elementModifier:function(t,e,s,r){return jt.elementModifier({path:Ht(t),params:e||[],hash:s||$t([]),loc:_t(r||null)})},attr:function(t,e,s){return jt.attr({name:t,value:e,loc:_t(s||null)})},text:function(t="",e){return jt.text({chars:t,loc:_t(e||null)})},sexpr:function(t,e=[],s=$t([]),r){return jt.sexpr({path:Ht(t),params:e,hash:s,loc:_t(r||null)})},concat:function(t,s){if(!e(t))throw new Error("b.concat requires at least one part");return jt.concat({parts:t,loc:_t(s||null)})},hash:$t,pair:function(t,e,s){return jt.pair({key:t,value:e,loc:_t(s||null)})},literal:Ft,program:function(t,e,s){return i("b.program is deprecated. Use b.template or b.blockItself instead."),e&&e.length?Mt(t,e,!1,s):It(t,[],s)},blockItself:Mt,template:It,loc:_t,pos:function(t,e){return jt.pos({line:t,column:e})},path:Ht,fullPath:function(t,e=[],s){return jt.path({head:t,tail:e,loc:_t(s||null)})},head:function(t,e){return jt.head({original:t,loc:_t(e||null)})},at:function(t,e){return jt.atName({name:t,loc:_t(e||null)})},var:Ot,this:function(t){return jt.this({loc:_t(t||null)})},string:Dt("StringLiteral"),boolean:Dt("BooleanLiteral"),number:Dt("NumberLiteral"),undefined:()=>Ft("UndefinedLiteral",void 0),null:()=>Ft("NullLiteral",null)};function Dt(t){return function(e,s){return Ft(t,e,s)}}const Vt={close:!1,open:!1};const jt=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:s=!1,loc:r}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>jt.var({name:t,loc:Y.synthetic(t)})))},chained:s,loc:r}}template({body:t,blockParams:e,loc:s}){return{type:"Template",body:t,blockParams:e,loc:s}}mustache({path:t,params:e,hash:s,trusting:r,loc:n,strip:a=Vt}){return function({path:t,params:e,hash:s,trusting:r,strip:n,loc:a}){const o={type:"MustacheStatement",path:t,params:e,hash:s,trusting:r,strip:n,loc:a};return Object.defineProperty(o,"escaped",{enumerable:!1,get(){return i("The escaped property on mustache nodes is deprecated, use trusting instead"),!this.trusting},set(t){i("The escaped property on mustache nodes is deprecated, use trusting instead"),this.trusting=!t}}),o}({path:t,params:e,hash:s,trusting:r,strip:a,loc:n})}block({path:t,params:e,hash:s,defaultBlock:r,elseBlock:n=null,loc:a,openStrip:i=Vt,inverseStrip:o=Vt,closeStrip:l=Vt}){return{type:"BlockStatement",path:t,params:e,hash:s,program:r,inverse:n,loc:a,openStrip:i,inverseStrip:o,closeStrip:l}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c,get tag(){return this.path.original},set tag(t){this.path.original=t},get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>jt.var({name:t,loc:Y.synthetic(t)})))},get selfClosing(){return h},set selfClosing(t){h=t,this.closeTag=t?null:Y.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:s,loc:r}){return{type:"ElementModifierStatement",path:t,params:e,hash:s,loc:r}}attr({name:t,value:e,loc:s}){return{type:"AttrNode",name:t,value:e,loc:s}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:s,loc:r}){return{type:"SubExpression",path:t,params:e,hash:s,loc:r}}path({head:t,tail:e,loc:s}){return function({head:t,tail:e,loc:s}){const r={type:"PathExpression",head:t,tail:e,get original(){return[this.head.original,...this.tail].join(".")},set original(t){let[e,...s]=o(t.split("."));this.head=Ut.head(e,this.head.loc),this.tail=s},loc:s};return Object.defineProperty(r,"parts",{enumerable:!1,get(){return i("The parts property on path nodes is deprecated, use trusting instead"),Object.freeze(this.original.split("."))},set(t){i("The parts property on mustache nodes is deprecated, use trusting instead"),this.original=t.join(".")}}),Object.defineProperty(r,"this",{enumerable:!1,get(){return i("The this property on path nodes is deprecated, use head.type instead"),"ThisHead"===this.head.type}}),Object.defineProperty(r,"data",{enumerable:!1,get(){return i("The data property on path nodes is deprecated, use head.type instead"),"AtHead"===this.head.type}}),r}({head:t,tail:e,loc:s})}head({original:t,loc:e}){return"this"===t?this.this({loc:e}):"@"===t[0]?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:e,loc:s}){let r="";const n={type:"AtHead",get name(){return r},set name(e){t("@"===e[0],"call builders.at() with a string that starts with '@'"),t(-1===e.indexOf("."),"builder.at() should not be called with a name with dots in it"),r=e},get original(){return this.name},set original(t){this.name=t},loc:s};return n.name=e,n}var({name:e,loc:s}){let r="";const n={type:"VarHead",get name(){return r},set name(s){t("this"!==s,"You called builders.var() with 'this'. Call builders.this instead"),t("@"!==s[0],`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),t(-1===s.indexOf("."),"builder.var() should not be called with a name with dots in it"),r=s},get original(){return this.name},set original(t){this.name=t},loc:s};return n.name=e,n}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:s}){return{type:"HashPair",key:t,value:e,loc:s}}literal({type:t,value:e,loc:s}){return function({type:t,value:e,loc:s}){const r={type:t,value:e,loc:s};return Object.defineProperty(r,"original",{enumerable:!1,get(){return i("The original property on literal nodes is deprecated, use value instead"),this.value},set(t){i("The original property on literal nodes is deprecated, use value instead"),this.value=t}}),r}({type:t,value:e,loc:s})}};class Gt{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(t,e=new f(b),s="precompile"){this.source=t,this.lines=t.source.split(/\r\n?|\n/u),this.tokenizer=new m(this,e,s)}offset(){let{line:t,column:e}=this.tokenizer;return this.source.offsetFor(t,e)}pos({line:t,column:e}){return this.source.offsetFor(t,e)}finish(t){return l({},t,{loc:t.start.until(this.offset())})}get currentAttr(){return c(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return t(e&&("StartTag"===e.type||"EndTag"===e.type),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return t(e&&"StartTag"===e.type,"expected start tag"),e}get currentEndTag(){let e=this.currentNode;return t(e&&"EndTag"===e.type,"expected end tag"),e}get currentComment(){let e=this.currentNode;return t(e&&"CommentStatement"===e.type,"expected a comment"),e}get currentData(){let e=this.currentNode;return t(e&&"TextNode"===e.type,"expected a text node"),e}acceptNode(t){return this[t.type](t)}currentElement(){return n(o(this.elementStack))}sourceForNode(t,e){let s,r,n,i=t.loc.start.line-1,o=i-1,l=t.loc.start.column,c=[];for(e?(r=e.loc.end.line-1,n=e.loc.end.column):(r=t.loc.end.line-1,n=t.loc.end.column);o<r;)o++,s=a(this.lines[o]),o===i?i===r?c.push(s.slice(l,n)):c.push(s.slice(l)):o===r?c.push(s.slice(0,n)):c.push(s);return c.join("\n")}}const Jt="beforeAttributeName";class Rt extends Gt{pendingError=null;parse(t,e){let s=jt.template({body:[],blockParams:e,loc:this.source.spanFor(t.loc)}),r=this.parseProgram(s,t);return this.pendingError?.eof(r.loc.getEnd()),r}Program(e,s){t(Array.isArray(s),"[BUG] Program in parser unexpectedly called without block params");let r=jt.blockItself({body:[],params:s,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(r,e)}parseProgram(e,s){if(0===s.body.length)return e;let r;try{this.elementStack.push(e);for(let t of s.body)this.acceptNode(t)}finally{r=this.elementStack.pop()}if(e!==r){if("ElementNode"===r?.type)throw ht(`Unclosed element \`${r.tag}\``,r.loc);t(void 0!==r,"[BUG] empty parser elementStack"),t(!1,`[BUG] mismatched parser elementStack node: ${e.type}`)}return e}BlockStatement(t){if("comment"===this.tokenizer.state)return void this.appendToCommentData(this.sourceForNode(t));if("data"!==this.tokenizer.state&&"beforeData"!==this.tokenizer.state)throw ht("A block may only be used inside an HTML element or another block.",this.source.spanFor(t.loc));const{path:e,params:s,hash:r}=Yt(this,t),n=this.source.spanFor(t.loc);let a=[];if(t.program.blockParams?.length){let e=r.loc.collapse("end");e=t.program.loc?e.withEnd(this.source.spanFor(t.program.loc).getStart()):t.program.body[0]?e.withEnd(this.source.spanFor(t.program.body[0].loc).getStart()):e.withEnd(n.getEnd());const s=e.asString();let i=s.indexOf("|")+1;const o=s.indexOf("|",i);for(const r of t.program.blockParams){let t,n;t=i>=o?-1:s.indexOf(r,i),-1===t||t+r.length>o?(i=o,n=this.source.spanFor(z)):(i=t,n=e.sliceStartChars({skipStart:i,chars:r.length}),i+=r.length),a.push(jt.var({name:r,loc:n}))}}t.program.loc||(t.program.loc=z),t.inverse&&!t.inverse.loc&&(t.inverse.loc=z);const i=this.Program(t.program,a),o=t.inverse?this.Program(t.inverse,[]):null,l=jt.block({path:e,params:s,hash:r,defaultBlock:i,elseBlock:o,loc:this.source.spanFor(t.loc),openStrip:t.openStrip,inverseStrip:t.inverseStrip,closeStrip:t.closeStrip});Tt(this.currentElement(),l)}MustacheStatement(t){this.pendingError?.mustache(this.source.spanFor(t.loc));const{tokenizer:e}=this;if("comment"===e.state)return void this.appendToCommentData(this.sourceForNode(t));let s;const{escaped:r,loc:n,strip:a}=t;if(At(t.path))s=jt.mustache({path:this.acceptNode(t.path),params:[],hash:jt.hash({pairs:[],loc:this.source.spanFor(t.path.loc).collapse("end")}),trusting:!r,loc:this.source.spanFor(n),strip:a});else{const{path:e,params:i,hash:o}=Yt(this,t);s=jt.mustache({path:e,params:i,hash:o,trusting:!r,loc:this.source.spanFor(n),strip:a})}switch(e.state){case"tagOpen":case"tagName":throw ht("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":Kt(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),Kt(this.currentStartTag,s),e.transitionTo(Jt);break;case"afterAttributeValueQuoted":Kt(this.currentStartTag,s),e.transitionTo(Jt);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),e.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:Tt(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(t){this.finalizeTextPart();const e=this.currentAttr;e.isDynamic=!0,e.parts.push(t)}finalizeTextPart(){const t=this.currentAttr.currentPart;null!==t&&(this.currentAttr.parts.push(t),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(t){!function(t,e){let s=e.loc.start.line,r=e.loc.start.column;const n=function(t,e){if(""===e)return{lines:t.split("\n").length-1,columns:0};const[s]=t.split(e),r=s.split(/\n/u),n=r.length-1;return{lines:n,columns:a(r[n]).length}}(e.original,e.value);s+=n.lines,n.lines?r=n.columns:r+=n.columns;t.line=s,t.column=r}(this.tokenizer,t),this.tokenizer.tokenizePart(t.value),this.tokenizer.flushData()}CommentStatement(t){const{tokenizer:e}=this;if("comment"===e.state)return this.appendToCommentData(this.sourceForNode(t)),null;const{value:s,loc:r}=t,n=jt.mustacheComment({value:s,loc:this.source.spanFor(r)});switch(e.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(n);break;case"beforeData":case"data":Tt(this.currentElement(),n);break;default:throw ht(`Using a Handlebars comment when in the \`${e.state}\` state is not supported`,this.source.spanFor(t.loc))}return n}PartialStatement(t){throw ht("Handlebars partials are not supported",this.source.spanFor(t.loc))}PartialBlockStatement(t){throw ht("Handlebars partial blocks are not supported",this.source.spanFor(t.loc))}Decorator(t){throw ht("Handlebars decorators are not supported",this.source.spanFor(t.loc))}DecoratorBlock(t){throw ht("Handlebars decorator blocks are not supported",this.source.spanFor(t.loc))}SubExpression(t){const{path:e,params:s,hash:r}=Yt(this,t);return jt.sexpr({path:e,params:s,hash:r,loc:this.source.spanFor(t.loc)})}PathExpression(t){const{original:e}=t;let s;if(-1!==e.indexOf("/")){if("./"===e.slice(0,2))throw ht('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(t.loc));if("../"===e.slice(0,3))throw ht('Changing context using "../" is not supported in Glimmer',this.source.spanFor(t.loc));if(-1!==e.indexOf("."))throw ht("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(t.loc));s=[t.parts.join("/")]}else{if("."===e)throw ht("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(t.loc));s=t.parts}let r,n=!1;if(/^this(?:\..+)?$/u.test(e)&&(n=!0),n)r=jt.this({loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+4}})});else if(t.data){const e=s.shift();if(void 0===e)throw ht("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(t.loc));r=jt.atName({name:`@${e}`,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length+1}})})}else{const e=s.shift();if(void 0===e)throw ht("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(t.loc));r=jt.var({name:e,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length}})})}return jt.path({head:r,tail:s,loc:this.source.spanFor(t.loc)})}Hash(t){const e=t.pairs.map((t=>jt.pair({key:t.key,value:this.acceptNode(t.value),loc:this.source.spanFor(t.loc)})));return jt.hash({pairs:e,loc:this.source.spanFor(t.loc)})}StringLiteral(t){return jt.literal({type:"StringLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}BooleanLiteral(t){return jt.literal({type:"BooleanLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}NumberLiteral(t){return jt.literal({type:"NumberLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}UndefinedLiteral(t){return jt.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(t.loc)})}NullLiteral(t){return jt.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(t.loc)})}}function Yt(t,s){let r;switch(s.path.type){case"PathExpression":r=t.PathExpression(s.path);break;case"SubExpression":r=t.SubExpression(s.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let e;throw e="BooleanLiteral"===s.path.type?s.path.original.toString():"StringLiteral"===s.path.type?`"${s.path.original}"`:"NullLiteral"===s.path.type?"null":"NumberLiteral"===s.path.type?s.path.value.toString():"undefined",ht(`${s.path.type} "${"StringLiteral"===s.path.type?s.path.original:e}" cannot be called as a sub-expression, replace (${e}) with ${e}`,t.source.spanFor(s.path.loc))}}const a=s.params?s.params.map((e=>t.acceptNode(e))):[],i=e(a)?n(a).loc:r.loc;return{path:r,params:a,hash:s.hash?t.Hash(s.hash):jt.hash({pairs:[],loc:t.source.spanFor(i).collapse("end")})}}function Kt(t,e){const{path:s,params:r,hash:n,loc:a}=e;if(At(s)){const r=`{{${function(t){return"UndefinedLiteral"===t.type?"undefined":JSON.stringify(t.value)}(s)}}}`;throw ht(`In ${`<${t.name} ... ${r} ...`}, ${r} is not a valid modifier`,e.loc)}const i=jt.elementModifier({path:s,params:r,hash:n,loc:a});t.modifiers.push(i)}function Qt(t){return/[\t\n\f ]/u.test(t)}class qt extends Rt{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(t){this.currentComment.value+=t}finishComment(){Tt(this.currentElement(),jt.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(t){this.currentData.chars+=t}finishData(){Tt(this.currentElement(),jt.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let t=this.finish(this.currentTag);if("StartTag"===t.type){if(this.finishStartTag(),":"===t.name)throw ht("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(N.has(t.name)||t.selfClosing)&&this.finishEndTag(!0)}else"EndTag"===t.type&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:s,nameEnd:r}=this.currentStartTag;t(""!==e,"tag name cannot be empty"),t(null!==s,"nameStart unexpectedly null"),t(null!==r,"nameEnd unexpectedly null");let n=s.until(r),[a,...i]=o(e.split(".")),l=jt.path({head:jt.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:c,modifiers:h,comments:u,params:p,selfClosing:d,loc:m}=this.finish(this.currentStartTag),f=jt.element({path:l,selfClosing:d,attributes:c,modifiers:h,comments:u,params:p,children:[],openTag:m,closeTag:d?null:Y.broken(),loc:m});this.elementStack.push(f)}finishEndTag(e){let{start:s}=this.currentTag,r=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(r,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?t(null===n.closeTag,"element.closeTag unexpectedly present"):n.closeTag=s.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),Tt(a,jt.element(n))}markTagAsSelfClosing(){let t=this.currentTag;if("StartTag"!==t.type)throw ht("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:t.start.toJSON(),end:this.offset().toJSON()}));t.selfClosing=!0}appendToTagName(e){let s=this.currentTag;if(s.name+=e,"StartTag"===s.type){let e=this.offset();null===s.nameStart&&(t(null===s.nameEnd,"nameStart and nameEnd must both be null"),s.nameStart=e.move(-1)),s.nameEnd=e}}beginAttribute(){let t=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:t,valueSpan:t.collapsed()}}appendToAttributeName(t){this.currentAttr.name+=t,"as"===this.currentAttr.name&&this.parsePossibleBlockParams()}beginAttributeValue(t){this.currentAttr.isQuoted=t,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(t){let e=this.currentAttr.parts,s=e[e.length-1],r=this.currentAttr.currentPart;if(r)r.chars+=t,r.loc=r.loc.withEnd(this.offset());else{let e=this.offset();e="\n"===t?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():e.move(-1),this.currentAttr.currentPart=jt.text({chars:t,loc:e.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let t=this.currentTag,e=this.offset();if("EndTag"===t.type)throw ht("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:t.start.toJSON(),end:e.toJSON()}));let{name:s,parts:r,start:n,isQuoted:a,isDynamic:i,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&0===r.length&&!a&&!i)throw ht("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",n.until(n.move(s.length)));let l=this.assembleAttributeValue(r,a,i,n.until(e));l.loc=o.withEnd(e);let c=jt.attr({name:s,value:l,loc:n.until(e)});this.currentStartTag.attributes.push(c)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;t("attributeName"===this.tokenizer.state,"must be in TokenizerState.attributeName");const s=this.currentStartTag,r=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:e=>{if(t("PossibleAs"===n.state,"bug in block params parser"),Qt(e))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if("|"===e)throw ht('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',r.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:e=>{t("BeforeStartPipe"===n.state,"bug in block params parser"),Qt(e)?this.tokenizer.consume():"|"===e?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:e=>{if(t("BeforeBlockParamName"===n.state,"bug in block params parser"),Qt(e))this.tokenizer.consume();else if(""===e)n={state:"Done"},this.pendingError={mustache(t){throw ht("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ht('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}};else if("|"===e){if(0===s.params.length)throw ht("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",r.start.until(this.offset().move(1)));n={state:"AfterEndPipe"}}else{if(">"===e||"/"===e)throw ht('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',r.start.until(this.offset().move(1)));n={state:"BlockParamName",name:e,start:this.offset()},this.tokenizer.consume()}},BlockParamName:a=>{if(t("BlockParamName"===n.state,"bug in block params parser"),""===a)n={state:"Done"},this.pendingError={mustache(t){throw ht("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ht('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}};else if("|"===a||Qt(a)){let t=n.start.until(this.offset());if("this"===n.name||e.test(n.name))throw ht(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,t);s.params.push(jt.var({name:n.name,loc:t})),n="|"===a?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(">"===a||"/"===a)throw ht('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',r.start.until(this.offset().move(1)));n.name+=a,this.tokenizer.consume()}},AfterEndPipe:e=>{t("AfterEndPipe"===n.state,"bug in block params parser"),Qt(e)?this.tokenizer.consume():""===e?(n={state:"Done"},this.pendingError={mustache(t){throw ht("Invalid block parameters syntax: modifiers cannot follow parameters list",t)},eof(t){throw ht('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}}):">"===e||"/"===e?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:e=>{if(t("Error"===n.state,"bug in block params parser"),""===e||"/"===e||">"===e||Qt(e))throw ht(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{t(!1,"This should never be called")}};let i;do{i=this.tokenizer.peek(),a[n.state](i)}while("Done"!==n.state&&""!==i);t("Done"===n.state,"bug in block params parser")}reportSyntaxError(t){throw ht(t,this.offset().collapsed())}assembleConcatenatedValue(t){for(const e of t)if("MustacheStatement"!==e.type&&"TextNode"!==e.type)throw ht(`Unsupported node in quoted attribute value: ${e.type}`,e.loc);h(t,"the concatenation parts of an element should not be empty");let e=r(t),s=n(t);return jt.concat({parts:t,loc:this.source.spanFor(e.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(t,e,s){if(N.has(t.name)&&!s)throw ht(`<${t.name}> elements do not need end tags. You should remove it`,t.loc);if(void 0===e.tag)throw ht(`Closing tag </${t.name}> without an open tag`,t.loc);if(e.tag!==t.name)throw ht(`Closing tag </${t.name}> did not match last open tag <${e.tag}> (on line ${e.loc.startPosition.line})`,t.loc)}assembleAttributeValue(t,s,r,n){if(r){if(s)return this.assembleConcatenatedValue(t);{h(t);const[e,s]=t;if(void 0===s||"TextNode"===s.type&&"/"===s.chars)return e;throw ht("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return e(t)?t[0]:jt.text({chars:"",loc:n})}}const Wt={parse:Zt,builders:Ut,print:L,traverse:Ct,Walker:Nt};class Xt extends f{constructor(){super({})}parse(){}}function Zt(t,e={}){let s,r,n,a=e.mode||"precompile";"string"==typeof t?(s=new nt(t,e.meta?.moduleName),r="codemod"===a?p(t,e.parseOptions):d(t,e.parseOptions)):t instanceof nt?(s=t,r="codemod"===a?p(t.source,e.parseOptions):d(t.source,e.parseOptions)):(s=new nt("",e.meta?.moduleName),r=t),"codemod"===a&&(n=new Xt);let i=Y.forCharPositions(s,0,s.source.length);r.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let o=new qt(s,n,a).parse(r,e.locals??[]);if(e?.plugins?.ast)for(const t of e.plugins.ast){Ct(o,t(l({},e,{syntax:Wt},{plugins:void 0})).visitor)}return o}function te(t,e,s,r){const n=function(t,e,s){if("PathExpression"===t.type){if("AtHead"===t.head.type||"ThisHead"===t.head.type)return;const s=t.head.name;if(-1===e.indexOf(s))return s}else if("ElementNode"===t.type){const{tag:r}=t,n=r.charAt(0);if(":"===n||"@"===n)return;if(!s.includeHtmlElements&&-1===r.indexOf(".")&&r.toLowerCase()===r)return;if("this."===r.substr(0,5))return;if(r.includes(".")){let[t]=r.split(".");if(e.includes(t))return}if(e.includes(r))return;return r}}(e,s,r);(Array.isArray(n)?n:[n]).forEach((e=>{if(void 0!==e&&"@"!==e[0]){const r=e.split(".")[0];s.includes(r)||t.add(e.split(".")[0])}}))}function ee(t,e={includeHtmlElements:!1,includeKeywords:!1}){const s=Zt(t),r=new Set,n=[];Ct(s,{Block:{enter({blockParams:t}){t.forEach((t=>{n.push(t)}))},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},ElementNode:{enter(t){t.blockParams.forEach((t=>{n.push(t)})),te(r,t,n,e)},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},PathExpression(t){te(r,t,n,e)}});let a=[];return r.forEach((t=>a.push(t))),e?.includeKeywords||(a=a.filter((t=>!O(t)))),a}function se(t){if(void 0!==t){const e=t;return{fields:()=>class{type;constructor(t){this.type=e,l(this,t)}}}}return{fields:()=>class{constructor(t){l(this,t)}}}}class re extends(se().fields()){static empty(t){return new re({loc:t,positional:ne.empty(t),named:ae.empty(t)})}static named(t){return new re({loc:t.loc,positional:ne.empty(t.loc.collapse("end")),named:t})}nth(t){return this.positional.nth(t)}get(t){return this.named.get(t)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class ne extends(se().fields()){static empty(t){return new ne({loc:t,exprs:[]})}get size(){return this.exprs.length}nth(t){return this.exprs[t]||null}isEmpty(){return 0===this.exprs.length}}class ae extends(se().fields()){static empty(t){return new ae({loc:t,entries:[]})}get size(){return this.entries.length}get(t){let e=this.entries.filter((e=>e.name.chars===t))[0];return e?e.value:null}isEmpty(){return 0===this.entries.length}}class ie{loc;name;value;constructor(t){this.loc=t.name.loc.extend(t.value.loc),this.name=t.name,this.value=t.value}}class oe extends(se("HtmlAttr").fields()){}class le extends(se("SplatAttr").fields()){}class ce extends(se().fields()){toNamedArgument(){return new ie({name:this.name,value:this.value})}}class he extends(se("ElementModifier").fields()){}class ue extends(se("GlimmerComment").fields()){}class pe extends(se("HtmlText").fields()){}class de extends(se("HtmlComment").fields()){}class me extends(se("AppendContent").fields()){get callee(){return"Call"===this.value.type?this.value.callee:this.value}get args(){return"Call"===this.value.type?this.value.args:re.empty(this.value.loc.collapse("end"))}}class fe extends(se("InvokeBlock").fields()){}class be extends(se("InvokeComponent").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return re.named(new ae({loc:at.range(t,this.callee.loc.collapse("end")),entries:t}))}}class ge extends(se("SimpleElement").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return re.named(new ae({loc:at.range(t,this.tag.loc.collapse("end")),entries:t}))}}class ke extends(se("Literal").fields()){toSlice(){return new R({loc:this.loc,chars:this.value})}}class ye extends(se("Path").fields()){}class we extends(se("Call").fields()){}class ve extends(se("DeprecatedCall").fields()){}class Se extends(se("Interpolate").fields()){}class xe extends(se().fields()){}class Pe extends(se().fields()){}class Ce extends(se().fields()){get(t){return this.blocks.filter((e=>e.name.chars===t))[0]||null}}class Ne extends(se().fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return re.named(new ae({loc:at.range(t,this.name.loc.collapse("end")),entries:t}))}}class Ee extends(se("This").fields()){}class Te extends(se("Arg").fields()){}class Ae extends(se("Local").fields()){}class Be extends(se("Free").fields()){}const Le={resolution:()=>g.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},Oe={...Le,isAngleBracket:!0};class He{static namespaced(t,e=!1){return new He({namespaces:[t],fallback:!1},e)}static fallback(){return new He({namespaces:[],fallback:!0})}static append({invoke:t}){return new He({namespaces:[$e.Component,$e.Helper],fallback:!t})}static trustingAppend({invoke:t}){return new He({namespaces:[$e.Helper],fallback:!t})}static attr(){return new He({namespaces:[$e.Helper],fallback:!0})}constructor(t,e=!1){this.ambiguity=t,this.isAngleBracket=e}resolution(){if(0===this.ambiguity.namespaces.length)return g.GetStrictKeyword;if(1!==this.ambiguity.namespaces.length)return this.ambiguity.fallback?g.GetFreeAsComponentOrHelperHeadOrThisFallback:g.GetFreeAsComponentOrHelperHead;if(this.ambiguity.fallback)return g.GetFreeAsHelperHeadOrThisFallback;switch(this.ambiguity.namespaces[0]){case $e.Helper:return g.GetFreeAsHelperHead;case $e.Modifier:return g.GetFreeAsModifierHead;case $e.Component:return g.GetFreeAsComponentHead}}serialize(){return 0===this.ambiguity.namespaces.length?"Loose":1===this.ambiguity.namespaces.length?this.ambiguity.fallback?["ambiguous",_e.Attr]:["ns",this.ambiguity.namespaces[0]]:this.ambiguity.fallback?["ambiguous",_e.Append]:["ambiguous",_e.Invoke]}}const Fe=He.fallback();let $e=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const ze=$e.Helper,Me=$e.Modifier,Ie=$e.Component;var _e=function(t){return t.Append="Append",t.Attr="Attr",t.Invoke="Invoke",t}(_e||{});var Ue=Object.freeze({__proto__:null,ARGUMENT_RESOLUTION:Fe,AppendContent:me,ArgReference:Te,Args:re,Block:Pe,COMPONENT_NAMESPACE:Ie,CallExpression:we,ComponentArg:ce,DeprecatedCallExpression:ve,ElementModifier:he,FreeVarNamespace:$e,FreeVarReference:Be,GlimmerComment:ue,HELPER_NAMESPACE:ze,HTML_RESOLUTION:Oe,HtmlAttr:oe,HtmlComment:de,HtmlText:pe,InterpolateExpression:Se,InvokeBlock:fe,InvokeComponent:be,LiteralExpression:ke,LocalVarReference:Ae,LooseModeResolution:He,MODIFIER_NAMESPACE:Me,NamedArgument:ie,NamedArguments:ae,NamedBlock:Ne,NamedBlocks:Ce,PathExpression:ye,PositionalArguments:ne,STRICT_RESOLUTION:Le,SimpleElement:ge,SplatAttr:le,Template:xe,ThisReference:Ee,isLiteral:function(t,e){return"Literal"===t.type&&(void 0===e||("null"===e?null===t.value:typeof t.value===e))},isStrictResolution:function(t){return t===Le},loadResolution:function(t){if("string"==typeof t)switch(t){case"Loose":return He.fallback();case"Strict":return Le}switch(t[0]){case"ambiguous":switch(t[1]){case _e.Append:return He.append({invoke:!1});case _e.Attr:return He.attr();case _e.Invoke:return He.append({invoke:!0})}case"ns":return He.namespaced(t[1])}},node:se});class De{static top(t,e){return new Ve(t,e)}child(t){let e=t.map((t=>this.allocate(t)));return new je(this,t,e)}}class Ve extends De{constructor(t,e){super(),this.templateLocals=t,this.options=e}symbols=[];upvars=[];size=1;named=u();blocks=u();usedTemplateLocals=[];#t=!1;hasLexical(t){return this.options.lexicalScope(t)}getLexical(t){return this.allocateFree(t,Oe)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#t=!0}get hasEval(){return this.#t}has(t){return this.templateLocals.includes(t)}get(t){let e=this.usedTemplateLocals.indexOf(t);return-1!==e||(e=this.usedTemplateLocals.length,this.usedTemplateLocals.push(t)),[e,!0]}getLocalsMap(){return u()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(t,e){e.resolution()===g.GetFreeAsComponentHead&&e.isAngleBracket&&(t=this.options.customizeComponentName(t));let s=this.upvars.indexOf(t);return-1!==s||(s=this.upvars.length,this.upvars.push(t)),s}allocateNamed(t){let e=this.named[t];return e||(e=this.named[t]=this.allocate(t)),e}allocateBlock(t){"inverse"===t&&(t="else");let e=this.blocks[t];return e||(e=this.blocks[t]=this.allocate(`&${t}`)),e}allocate(t){return this.symbols.push(t),this.size++}}class je extends De{constructor(t,e,s){super(),this.parent=t,this.symbols=e,this.slots=s}get locals(){return this.symbols}getLexical(t){return this.parent.getLexical(t)}hasLexical(t){return this.parent.hasLexical(t)}has(t){return-1!==this.symbols.indexOf(t)||this.parent.has(t)}get(t){let e=this.#e(t);return e?[e,!1]:this.parent.get(t)}#e(t){let e=this.symbols.indexOf(t);return-1===e?null:a(this.slots[e])}getLocalsMap(){let t=this.parent.getLocalsMap();return this.symbols.forEach((e=>t[e]=this.get(e)[0])),t}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(t,e){return this.parent.allocateFree(t,e)}allocateNamed(t){return this.parent.allocateNamed(t)}allocateBlock(t){return this.parent.allocateBlock(t)}allocate(t){return this.parent.allocate(t)}}var Ge=Object.freeze({__proto__:null});class Je{template(t,e,s){return new xe({table:t,body:e,loc:s})}block(t,e,s){return new Pe({scope:t,body:e,loc:s})}namedBlock(t,e,s){return new Ne({name:t,block:e,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(t,e,s){return new Re({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(t,e,s)}slice(t,e){return new R({loc:e,chars:t})}args(t,e,s){return new re({loc:s,positional:t,named:e})}positional(t,e){return new ne({loc:e,exprs:t})}namedArgument(t,e){return new ie({name:t,value:e})}named(t,e){return new ae({loc:e,entries:t})}attr({name:t,value:e,trusting:s},r){return new oe({loc:r,name:t,value:e,trusting:s})}splatAttr(t,e){return new le({symbol:t,loc:e})}arg({name:t,value:e,trusting:s},r){return new ce({name:t,value:e,trusting:s,loc:r})}path(t,e,s){return new ye({loc:s,ref:t,tail:e})}self(t){return new Ee({loc:t})}at(e,s,r){return t("@"===e[0],"call builders.at() with a string that starts with '@'"),new Te({loc:r,name:new R({loc:r,chars:e}),symbol:s})}freeVar({name:e,context:s,symbol:r,loc:n}){return t("this"!==e,"You called builders.freeVar() with 'this'. Call builders.this instead"),t("@"!==e[0],`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new Be({name:e,resolution:s,symbol:r,loc:n})}localVar(e,s,r,n){return t("this"!==e,"You called builders.var() with 'this'. Call builders.this instead"),t("@"!==e[0],`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new Ae({loc:n,name:e,isTemplateLocal:r,symbol:s})}sexp(t,e){return new we({loc:e,callee:t.callee,args:t.args})}deprecatedCall(t,e,s){return new ve({loc:s,arg:t,callee:e})}interpolate(t,e){return h(t),new Se({loc:e,parts:t})}literal(t,e){return new ke({loc:e,value:t})}append({table:t,trusting:e,value:s},r){return new me({table:t,trusting:e,value:s,loc:r})}modifier({callee:t,args:e},s){return new he({loc:s,callee:t,args:e})}namedBlocks(t,e){return new Ce({loc:e,blocks:t})}blockStatement({program:t,inverse:e=null,...s},r){let n=t.loc,a=[this.namedBlock(R.synthetic("default"),t,t.loc)];return e&&(n=n.extend(e.loc),a.push(this.namedBlock(R.synthetic("else"),e,e.loc))),new fe({loc:r,blocks:this.namedBlocks(a,n),callee:s.callee,args:s.args})}element(t){return new Re(t)}}class Re{builder;constructor(t){this.base=t,this.builder=new Je}simple(t,e,s){return new ge(l({tag:t,body:e,componentArgs:[],loc:s},this.base))}named(t,e,s){return new Ne(l({name:t,block:e,componentArgs:[],loc:s},this.base))}selfClosingComponent(t,e){return new be(l({loc:e,callee:t,blocks:new Ce({blocks:[],loc:e.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(t,e,s,r){let n=this.builder.block(s,e,r),a=this.builder.namedBlock(R.synthetic("default"),n,r);return new be(l({loc:r,callee:t,blocks:this.builder.namedBlocks([a],a.loc)},this.base))}componentWithNamedBlocks(t,e,s){return new be(l({loc:s,callee:t,blocks:this.builder.namedBlocks(e,at.range(e))},this.base))}}function Ye(t){return Ze(t)?He.namespaced(ze):null}function Ke(t){return Ze(t)?He.namespaced(Me):null}function Qe(t){return Ze(t)?He.namespaced(Ie):He.fallback()}function qe(t){return ts(t)?He.namespaced($e.Component,!0):null}function We(t){let e=Ze(t),s=es(t);return e?s?He.namespaced($e.Helper):He.attr():s?Le:He.fallback()}function Xe(t){let e=Ze(t),s=es(t),r=t.trusting;return e?r?He.trustingAppend({invoke:s}):He.append({invoke:s}):He.fallback()}function Ze(t){return ts(t.path)}function ts(t){return"PathExpression"===t.type&&"VarHead"===t.head.type&&0===t.tail.length}function es(t){return t.params.length>0||t.hash.pairs.length>0}function ss(t,e={lexicalScope:()=>!1}){let s=Zt(t,e),r={strictMode:!1,...e,locals:s.blockParams},n=De.top(r.locals,{customizeComponentName:e.customizeComponentName??(t=>t),lexicalScope:e.lexicalScope}),a=new rs(t,r,n),i=new as(a),o=new ls(a.loc(s.loc),s.body.map((t=>i.normalize(t))),a).assertTemplate(n);return[o,n.getUsedTemplateLocals()]}class rs{builder;constructor(t,e,s){this.source=t,this.options=e,this.table=s,this.builder=new Je}get strict(){return this.options.strictMode||!1}loc(t){return this.source.spanFor(t)}resolutionFor(t,e){if(this.strict)return{result:Le};if(this.isFreeVar(t)){let s=e(t);return null===s?{result:"error",path:ds(t),head:ms(t)}:{result:s}}return{result:Le}}isLexicalVar(t){return this.table.hasLexical(t)}isFreeVar(t){return"PathExpression"===t.type?"VarHead"===t.head.type&&!this.table.has(t.head.name):"PathExpression"===t.path.type&&this.isFreeVar(t.path)}hasBinding(t){return this.table.has(t)||this.table.hasLexical(t)}child(t){return new rs(this.source,this.options,this.table.child(t))}customizeComponentName(t){return this.options.customizeComponentName?this.options.customizeComponentName(t):t}}class ns{constructor(t){this.block=t}normalize(t,e){switch(t.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(t.value,this.block.loc(t.loc));case"PathExpression":return this.path(t,e);case"SubExpression":{us(t.path)&&ps(t.path,t.loc);let e=this.block.resolutionFor(t,Ye);if("error"===e.result)throw ht(`You attempted to invoke a path (\`${e.path}\`) but ${e.head} was not in scope`,t.loc);return this.block.builder.sexp(this.callParts(t,e.result),this.block.loc(t.loc))}}}path(t,e){let s=[],r=this.block.loc(t.head.loc);for(let e of t.tail)r=r.sliceStartChars({chars:e.length,skipStart:1}),s.push(new R({loc:r,chars:e}));return this.block.builder.path(this.ref(t.head,e),s,this.block.loc(t.loc))}callParts(t,e){let{path:s,params:r,hash:n}=t,a=this.normalize(s,e),i=r.map((t=>this.normalize(t,Fe))),o=at.range(i,a.loc.collapse("end")),l=this.block.loc(n.loc),c=at.range([o,l]),h=this.block.builder.positional(r.map((t=>this.normalize(t,Fe))),o),u=this.block.builder.named(n.pairs.map((t=>this.namedArgument(t))),this.block.loc(n.loc));return{callee:a,args:this.block.builder.args(h,u,c)}}namedArgument(t){let e=this.block.loc(t.loc).sliceStartChars({chars:t.key.length});return this.block.builder.namedArgument(new R({chars:t.key,loc:e}),this.normalize(t.value,Fe))}ref(t,e){let{block:s}=this,{builder:r,table:n}=s,a=s.loc(t.loc);switch(t.type){case"ThisHead":return r.self(a);case"AtHead":{let e=n.allocateNamed(t.name);return r.at(t.name,e,a)}case"VarHead":if(s.hasBinding(t.name)){let[e,r]=n.get(t.name);return s.builder.localVar(t.name,e,r,a)}{let r=s.strict?Le:e,n=s.table.allocateFree(t.name,r);return s.builder.freeVar({name:t.name,context:r,symbol:n,loc:a})}}}}class as{constructor(t){this.block=t}normalize(t){switch(t.type){case"BlockStatement":return this.BlockStatement(t);case"ElementNode":return new is(this.block).ElementNode(t);case"MustacheStatement":return this.MustacheStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":{let e=this.block.loc(t.loc);return new de({loc:e,text:e.slice({skipStart:4,skipEnd:3}).toSlice(t.value)})}case"TextNode":return new pe({loc:this.block.loc(t.loc),chars:t.chars})}}MustacheCommentStatement(t){let e,s=this.block.loc(t.loc);return e="{{!--"===s.asString().slice(0,5)?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new ue({loc:s,text:e.toSlice(t.value)})}MustacheStatement(t){let e,{path:s,params:r,hash:n,trusting:a}=t,i=this.block.loc(t.loc),o=Xe(t);if(us(s))0===r.length&&0===n.pairs.length?e=this.expr.normalize(s,o):ps(s,i);else{let a=this.expr.callParts({path:s,params:r,hash:n},Xe(t));e=a.args.isEmpty()?a.callee:this.block.builder.sexp(a,i)}return this.block.builder.append({table:this.block.table,trusting:a,value:e},i)}BlockStatement(t){let{program:e,inverse:s}=t,r=this.block.loc(t.loc);us(t.path)&&ps(t.path,r);let n=this.block.resolutionFor(t,Qe);if("error"===n.result)throw ht(`You attempted to invoke a path (\`{{#${n.path}}}\`) but ${n.head} was not in scope`,r);let a=this.expr.callParts(t,n.result);return this.block.builder.blockStatement(l({symbols:this.block.table,program:this.Block(e),inverse:s?this.Block(s):null},a),r)}Block({body:t,loc:e,blockParams:s}){let r=this.block.child(s),n=new as(r);return new cs(this.block.loc(e),t.map((t=>n.normalize(t))),this.block).assertBlock(r.table)}get expr(){return new ns(this.block)}}class is{constructor(t){this.ctx=t}ElementNode(t){let{tag:e,selfClosing:s,comments:r}=t,n=this.ctx.loc(t.loc),[a,...i]=o(e.split(".")),l=this.classifyTag(a,i,t.loc),c=t.attributes.filter((t=>"@"!==t.name[0])).map((t=>this.attr(t))),h=t.attributes.filter((t=>"@"===t.name[0])).map((t=>this.arg(t))),u=t.modifiers.map((t=>this.modifier(t))),p=this.ctx.child(t.blockParams),d=new as(p),m=t.children.map((t=>d.normalize(t))),f=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:u,comments:r.map((t=>new as(this.ctx).MustacheCommentStatement(t)))}),b=new hs(f,n,m,this.ctx),g=this.ctx.loc(t.loc).sliceStartChars({chars:e.length,skipStart:1});if("ElementHead"===l)return":"===e[0]?b.assertNamedBlock(g.slice({skipStart:1}).toSlice(e.slice(1)),p.table):b.assertElement(g.toSlice(e),t.blockParams.length>0);if(t.selfClosing)return f.selfClosingComponent(l,n);{let s=b.assertComponent(e,p.table,t.blockParams.length>0);return f.componentWithNamedBlocks(l,s,n)}}modifier(t){us(t.path)&&ps(t.path,t.loc);let e=this.ctx.resolutionFor(t,Ke);if("error"===e.result)throw ht(`You attempted to invoke a path (\`{{#${e.path}}}\`) as a modifier, but ${e.head} was not in scope. Try adding \`this\` to the beginning of the path`,t.loc);let s=this.expr.callParts(t,e.result);return this.ctx.builder.modifier(s,this.ctx.loc(t.loc))}mustacheAttr(t){let{path:e,params:s,hash:r,loc:n}=t,a=We(t);if(us(e)){if(0===s.length&&0===r.pairs.length)return this.expr.normalize(e,a);ps(e,n)}let i=this.ctx.builder.sexp(this.expr.callParts(t,We(t)),this.ctx.loc(n));return i.args.isEmpty()?i.callee:i}attrPart(t){switch(t.type){case"MustacheStatement":return{expr:this.mustacheAttr(t),trusting:t.trusting};case"TextNode":return{expr:this.ctx.builder.literal(t.chars,this.ctx.loc(t.loc)),trusting:!0}}}attrValue(t){if("ConcatStatement"===t.type){let e=t.parts.map((t=>this.attrPart(t).expr));return{expr:this.ctx.builder.interpolate(e,this.ctx.loc(t.loc)),trusting:!1}}return this.attrPart(t)}attr(e){if(t("@"!==e.name[0],"An attr name must not start with `@`"),"...attributes"===e.name)return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let s=this.ctx.loc(e.loc),r=s.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:r,value:n.expr,trusting:n.trusting},s)}maybeDeprecatedCall(t,e){if(this.ctx.strict)return null;if("MustacheStatement"!==e.type)return null;let{path:s}=e;if("PathExpression"!==s.type)return null;if("VarHead"!==s.head.type)return null;let{name:r}=s.head;if("has-block"===r||"has-block-params"===r)return null;if(this.ctx.hasBinding(r))return null;if(0!==s.tail.length)return null;if(0!==e.params.length||0!==e.hash.pairs.length)return null;let n=He.attr(),a=this.ctx.builder.freeVar({name:r,context:n,symbol:this.ctx.table.allocateFree(r,n),loc:s.loc});return{expr:this.ctx.builder.deprecatedCall(t,a,e.loc),trusting:!1}}arg(e){t("@"===e.name[0],"An arg name must start with `@`");let s=this.ctx.loc(e.loc),r=s.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.maybeDeprecatedCall(r,e.value)||this.attrValue(e.value);return this.ctx.builder.arg({name:r,value:n.expr,trusting:n.trusting},s)}classifyTag(t,e,s){let r=(n=t)[0]===n[0]?.toUpperCase()&&n[0]!==n[0]?.toLowerCase();var n;let a="@"===t[0]||"this"===t||this.ctx.hasBinding(t);if(this.ctx.strict&&!a){if(r)throw ht(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${t}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${t.toLowerCase()}>\``,s);return"ElementHead"}let i=a||r,o=s.sliceStartChars({skipStart:1,chars:t.length}),l=e.reduce(((t,e)=>t+1+e.length),0),c=o.getEnd().move(l),h=o.withEnd(c);if(i){let r=jt.path({head:jt.head({original:t,loc:o}),tail:e,loc:h}),n=this.ctx.isLexicalVar(t)?{result:Le}:this.ctx.resolutionFor(r,qe);if("error"===n.result)throw ht(`You attempted to invoke a path (\`<${n.path}>\`) but ${n.head} was not in scope`,s);return new ns(this.ctx).normalize(r,n.result)}if(this.ctx.table.allocateFree(t,Le),e.length>0)throw ht(`You used ${t}.${e.join(".")} as a tag name, but ${t} is not in scope`,s);return"ElementHead"}get expr(){return new ns(this.ctx)}}class os{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(t,e,s){this.loc=t,this.children=e,this.block=s,this.namedBlocks=e.filter((t=>t instanceof Ne)),this.hasSemanticContent=Boolean(e.filter((t=>{if(t instanceof Ne)return!1;switch(t.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(t.chars);default:return!0}})).length),this.nonBlockChildren=e.filter((t=>!(t instanceof Ne)))}}class ls extends os{assertTemplate(t){if(e(this.namedBlocks))throw ht("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(t,this.nonBlockChildren,this.block.loc(this.loc))}}class cs extends os{assertBlock(t){if(e(this.namedBlocks))throw ht("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(t,this.nonBlockChildren,this.loc)}}class hs extends os{constructor(t,e,s,r){super(e,s,r),this.el=t}assertNamedBlock(t,s){if(this.el.base.selfClosing)throw ht(`<:${t.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(e(this.namedBlocks))throw ht(`Unexpected named block inside <:${t.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((r=t.chars)[0]!==r[0]?.toLowerCase()||r[0]===r[0]?.toUpperCase())throw ht(`<:${t.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var r;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw ht(`named block <:${t.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=at.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(t,this.block.builder.block(s,this.nonBlockChildren,n),this.loc)}assertElement(t,s){if(s)throw ht(`Unexpected block params in <${t}>: simple elements cannot have block params`,this.loc);if(e(this.namedBlocks)){let e=this.namedBlocks.map((t=>t.name));if(1===e.length)throw ht(`Unexpected named block <:foo> inside <${t.chars}> HTML element`,this.loc);{let s=e.map((t=>`<:${t.chars}>`)).join(", ");throw ht(`Unexpected named blocks inside <${t.chars}> HTML element (${s})`,this.loc)}}return this.el.simple(t,this.nonBlockChildren,this.loc)}assertComponent(t,s,r){if(e(this.namedBlocks)&&this.hasSemanticContent)throw ht(`Unexpected content inside <${t}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(e(this.namedBlocks)){if(r)throw ht(`Unexpected block params list on <${t}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let e=new Set;for(let t of this.namedBlocks){let s=t.name.chars;if(e.has(s))throw ht(`Component had two named blocks with the same name, \`<:${s}>\`. Only one block with a given name may be passed`,this.loc);if("inverse"===s&&e.has("else")||"else"===s&&e.has("inverse"))throw ht("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);e.add(s)}return this.namedBlocks}return[this.block.builder.namedBlock(R.synthetic("default"),this.block.builder.block(s,this.nonBlockChildren,this.loc),this.loc)]}}function us(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function ps(t,e){throw ht(`Unexpected literal \`${"StringLiteral"===t.type?JSON.stringify(t.value):String(t.value)}\``,e)}function ds(t){return"PathExpression"!==t.type&&"PathExpression"===t.path.type?ds(t.path):new B({entityEncoding:"raw"}).print(t)}function ms(t){return"PathExpression"===t.type?t.head.original:"PathExpression"===t.path.type?ms(t.path):new B({entityEncoding:"raw"}).print(t)}export{Ge as AST,Ge as ASTv1,Ue as ASTv2,je as BlockSymbolTable,H as KEYWORDS_TYPES,Nt as Path,Ve as ProgramSymbolTable,R as SourceSlice,at as SpanList,De as SymbolTable,Nt as Walker,bt as WalkerPath,Ut as builders,dt as cannotRemoveNode,mt as cannotReplaceNode,ht as generateSyntaxError,ee as getTemplateLocals,E as getVoidTags,ot as hasSpan,O as isKeyword,A as isVoidTag,it as loc,lt as maybeLoc,se as node,ss as normalize,Zt as preprocess,L as print,C as sortByLoc,ct as src,Ct as traverse,ut as visitorKeys};
//# sourceMappingURL=index.js.map
